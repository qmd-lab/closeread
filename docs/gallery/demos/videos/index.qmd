---
title: "Videos"
# image: "globe.png"
subtitle: "Use videos that loop or progress on user scroll."
format:
  closeread-html:
    resources: rayshader.mp4
    cr-style:
      narrative-border-radius: 0
      narrative-background-color-overlay: "#d8e4f2aa"
      narrative-text-color-overlay: black
      narrative-background-color-sidebar: "#914e4e"
      narrative-text-color-sidebar: white
      section-background-color: "#213243"
---

Something something video

Now here's an example of a video filling to fit the space:

::::{.cr-section layout="overlay-left"}

You can tell all sorts of stories with videos.

Maybe you've gone on a journey.  
[Credit: [Cristian-Manieri/Pixabay](https://pixabay.com/videos/drone-landscape-green-greenland-236893/)]{style="font-size: 65%;"} @cr-ship

![](ship.mp4){#cr-ship .scale-to-cover alt="A ship sails in a polar region" loop="true"}

You can trigger a video to play using `[@cr-ship]{play-video="true"}`. [@cr-ship]{play-video="true"}

You can also pause it using `[@cr-ship]{pause-video="true"}`. [@cr-ship]{pause-video="true"}

Apply the `.scale-to-cover` class to videos to ensure that they fill up the whole Closeread sticky column (even if they need to be cropped to do it).

This is great for photojournalistic use cases like interviews where not every part of the frame needs to be visible.

::::

\
\

This works for sidebar layouts too:

\
\

::::{.cr-section layout="sidebar-right"}

The video may even be there simply to establish a mood for your story.  
[Credit: [Domka_1611/Pixabay](https://pixabay.com/videos/fire-evening-nature-forest-autumn-148594/)]{style="font-size: 65%;"} @cr-tea

![](tea.mp4){#cr-tea .scale-to-cover alt="One person pours tea into another person's tea cup in front of an open fire." autoplay="true" loop="true"}

:::{focus-on="cr-tea"}
You may want to add `autoplay="true"` and `loop="true"` to your videos.
\
\
In this case, we've shifted the video and put a crossfade in the middle of it for a seamless loop.
:::

::::

\
\

# Videos that progress on scroll

Let's use the popular `{rayshader}` package to generate a video like that. First, we'll build the scene up:

```{r}
#| label: build-scene
#| echo: true
#| code-fold: false
library(tibble)
library(dplyr)
library(stringr)
library(purrr)
library(rayshader)

mont_shadow <- ray_shade(montereybay, zscale = 50, lambert = FALSE)
mont_amb <- ambient_shade(montereybay, zscale = 50)
montereybay |>
  sphere_shade(zscale = 10, texture = "imhof1") |>
  add_shadow(mont_shadow, 0.5) |>
  add_shadow(mont_amb, 0) ->
mont_scene
```

Now we'll render the movie as `rayshader.mp4`:

```{r}
#| label: render-images
#| echo: true
#| code-fold: false
plot_3d(
  mont_scene, montereybay, zscale = 50, fov = 0, phi = 45,
  windowsize = c(1000, 800), zoom = 0.75, water = TRUE, waterdepth = 0,
  wateralpha = 0.5, watercolor = "lightblue", waterlinecolor = "white",
  waterlinealpha = 0.5)

render_movie("rayshader.mp4")
```

Let's incorporate `rayshader.mp4` into a scrolly section.

:::::{.cr-section}

Here's our rayshader video! It scrolls! [@cr-rayshader]{scroll-video="true"}

But wait, it seems to reset on our next trigger. @cr-rayshader

What's up with that? @cr-rayshader

![](rayshader.mp4){#cr-rayshader alt="A rotating landscape made with Rayrender."}
:::::

\
\
\

You might notice that the scrolly video resets with each trigger. That's not ideal!

Most of the time, you're better off tying the scrolling video to a progress block:

\
\
\

:::::{.cr-section}

::::{.progress-block focus-on="cr-rayshader-prog" scroll-video="true"}

Here's our rayshader video again!

Notice that the video scrolls across several triggers...

... rather than resetting as each one passes.

::::

![](rayshader.mp4){#cr-rayshader-prog alt="A rotating landscape made with Rayrender."}
:::::

:::{.counter style="position: fixed; top: 10px; right: 10px; background-color: skyblue; border-radius: 5px; padding: 18px 18px 0 18px; line-height: .8em; z-index: 1000"}
```{ojs}
md`Active sticky: ${crActiveSticky}`
md`Active trigger: ${crTriggerIndex}`
md`Trigger progress: ${(crTriggerProgress * 100).toFixed(1)}%`
md`Scroll direction: ${crDirection}`
md`Progress Block progress: ${(crProgressBlock * 100).toFixed(1)}%`
```
:::
